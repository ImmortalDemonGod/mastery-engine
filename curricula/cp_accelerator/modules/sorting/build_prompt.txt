# Build Challenge: Sort an Array

## Pattern Overview

> Sorting algorithms organize data in a specific order, enabling efficient searching, data analysis, and serving as building blocks for more complex algorithms.

## Pattern Taxonomy

```mermaid

```

## Your Task

Implement a solution to the following problem, which is a canonical example of this pattern.

### Problem: 912. Sort an Array

**Problem Link:** https://leetcode.com/problems/sort-an-array

**Problem Statement:**
[Note: Visit the problem link above for the complete statement, examples, and constraints]

## Implementation Requirements

1. **Language:** Python 3 (or your preferred language)
2. **File:** `solution.py`
3. **Function Signature:** Will be provided based on the problem
4. **Constraints:** Must pass all example test cases from the problem statement

## Local Validation

After implementing your solution:

```bash
engine submit
```

**Important Note on Validation:**
- The local validator runs against example test cases extracted from the problem statement
- Passing local tests is **necessary but not sufficient** for full correctness
- For complete validation, submit your solution to https://leetcode.com/problems/sort-an-array
- The Mastery Engine focuses on verifying you understand the pattern and can implement a working solution

## Learning Resources

These curated resources will help you understand the pattern deeply:

1. https://www.youtube.com/watch?v=kPRA0W1kECg
2. https://www.geeksforgeeks.org/sorting-algorithms/

## Why This Problem Matters

Sorting is one of the most fundamental operations in computer science:
- **Foundation for other algorithms**: Binary search, merge operations, scheduling
- **Interview frequency**: Appears in 20%+ of technical interviews
- **Real-world applications**: Database query optimization, file systems, data analysis
- **Complexity baseline**: Understanding O(n log n) vs O(nÂ²) is essential

You'll implement merge sort, a divide-and-conquer algorithm that:
1. Divides the array into halves recursively
2. Conquers by sorting each half
3. Combines by merging two sorted arrays

## Implementation Strategy

**Step 1: Base Case**
```python
if len(nums) <= 1:
    return nums  # Already sorted
```

**Step 2: Divide**
```python
mid = len(nums) // 2
left = sortArray(nums[:mid])
right = sortArray(nums[mid:])
```

**Step 3: Merge**
```python
return merge(left, right)
```

The merge function is the key:
- Takes two sorted arrays
- Returns one sorted array
- Uses two pointers to track progress

## Common Pitfalls

1. **Forgetting the base case**: Always handle empty arrays and single elements
2. **Incomplete merge**: After the main loop, don't forget remaining elements
3. **Wrong comparison**: Use `<=` not `<` for stable sorting
4. **Index out of bounds**: Check both `i < len(left)` and `j < len(right)`

## Hints

If you're stuck:
1. **Draw it out**: Trace merge([1, 3], [2, 4]) on paper
2. **Start with merge**: Implement the merge function first and test it independently
3. **Test edge cases**: [], [1], [1, 1], [3, 2, 1]
4. **Think recursively**: Trust that recursive calls work correctly

## Submission

Once your solution passes local tests:
```bash
engine submit
```
